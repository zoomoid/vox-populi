// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"

	"github.com/zoomoid/vox-populi/backend/pkg/v1/data/ent/migrate"

	"github.com/zoomoid/vox-populi/backend/pkg/v1/data/ent/poll"
	"github.com/zoomoid/vox-populi/backend/pkg/v1/data/ent/reaction"
	"github.com/zoomoid/vox-populi/backend/pkg/v1/data/ent/reactiontemplate"
	"github.com/zoomoid/vox-populi/backend/pkg/v1/data/ent/vote"
	"github.com/zoomoid/vox-populi/backend/pkg/v1/data/ent/votetemplate"

	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Poll is the client for interacting with the Poll builders.
	Poll *PollClient
	// Reaction is the client for interacting with the Reaction builders.
	Reaction *ReactionClient
	// ReactionTemplate is the client for interacting with the ReactionTemplate builders.
	ReactionTemplate *ReactionTemplateClient
	// Vote is the client for interacting with the Vote builders.
	Vote *VoteClient
	// VoteTemplate is the client for interacting with the VoteTemplate builders.
	VoteTemplate *VoteTemplateClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Poll = NewPollClient(c.config)
	c.Reaction = NewReactionClient(c.config)
	c.ReactionTemplate = NewReactionTemplateClient(c.config)
	c.Vote = NewVoteClient(c.config)
	c.VoteTemplate = NewVoteTemplateClient(c.config)
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:              ctx,
		config:           cfg,
		Poll:             NewPollClient(cfg),
		Reaction:         NewReactionClient(cfg),
		ReactionTemplate: NewReactionTemplateClient(cfg),
		Vote:             NewVoteClient(cfg),
		VoteTemplate:     NewVoteTemplateClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:              ctx,
		config:           cfg,
		Poll:             NewPollClient(cfg),
		Reaction:         NewReactionClient(cfg),
		ReactionTemplate: NewReactionTemplateClient(cfg),
		Vote:             NewVoteClient(cfg),
		VoteTemplate:     NewVoteTemplateClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Poll.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.Poll.Use(hooks...)
	c.Reaction.Use(hooks...)
	c.ReactionTemplate.Use(hooks...)
	c.Vote.Use(hooks...)
	c.VoteTemplate.Use(hooks...)
}

// PollClient is a client for the Poll schema.
type PollClient struct {
	config
}

// NewPollClient returns a client for the Poll from the given config.
func NewPollClient(c config) *PollClient {
	return &PollClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `poll.Hooks(f(g(h())))`.
func (c *PollClient) Use(hooks ...Hook) {
	c.hooks.Poll = append(c.hooks.Poll, hooks...)
}

// Create returns a builder for creating a Poll entity.
func (c *PollClient) Create() *PollCreate {
	mutation := newPollMutation(c.config, OpCreate)
	return &PollCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Poll entities.
func (c *PollClient) CreateBulk(builders ...*PollCreate) *PollCreateBulk {
	return &PollCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Poll.
func (c *PollClient) Update() *PollUpdate {
	mutation := newPollMutation(c.config, OpUpdate)
	return &PollUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PollClient) UpdateOne(po *Poll) *PollUpdateOne {
	mutation := newPollMutation(c.config, OpUpdateOne, withPoll(po))
	return &PollUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PollClient) UpdateOneID(id int) *PollUpdateOne {
	mutation := newPollMutation(c.config, OpUpdateOne, withPollID(id))
	return &PollUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Poll.
func (c *PollClient) Delete() *PollDelete {
	mutation := newPollMutation(c.config, OpDelete)
	return &PollDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PollClient) DeleteOne(po *Poll) *PollDeleteOne {
	return c.DeleteOneID(po.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PollClient) DeleteOneID(id int) *PollDeleteOne {
	builder := c.Delete().Where(poll.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PollDeleteOne{builder}
}

// Query returns a query builder for Poll.
func (c *PollClient) Query() *PollQuery {
	return &PollQuery{
		config: c.config,
	}
}

// Get returns a Poll entity by its id.
func (c *PollClient) Get(ctx context.Context, id int) (*Poll, error) {
	return c.Query().Where(poll.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PollClient) GetX(ctx context.Context, id int) *Poll {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryVoteTemplates queries the vote_templates edge of a Poll.
func (c *PollClient) QueryVoteTemplates(po *Poll) *VoteTemplateQuery {
	query := &VoteTemplateQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := po.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(poll.Table, poll.FieldID, id),
			sqlgraph.To(votetemplate.Table, votetemplate.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, poll.VoteTemplatesTable, poll.VoteTemplatesColumn),
		)
		fromV = sqlgraph.Neighbors(po.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVotes queries the votes edge of a Poll.
func (c *PollClient) QueryVotes(po *Poll) *VoteQuery {
	query := &VoteQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := po.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(poll.Table, poll.FieldID, id),
			sqlgraph.To(vote.Table, vote.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, poll.VotesTable, poll.VotesColumn),
		)
		fromV = sqlgraph.Neighbors(po.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReactionTemplates queries the reaction_templates edge of a Poll.
func (c *PollClient) QueryReactionTemplates(po *Poll) *ReactionTemplateQuery {
	query := &ReactionTemplateQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := po.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(poll.Table, poll.FieldID, id),
			sqlgraph.To(reactiontemplate.Table, reactiontemplate.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, poll.ReactionTemplatesTable, poll.ReactionTemplatesColumn),
		)
		fromV = sqlgraph.Neighbors(po.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReactions queries the reactions edge of a Poll.
func (c *PollClient) QueryReactions(po *Poll) *ReactionQuery {
	query := &ReactionQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := po.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(poll.Table, poll.FieldID, id),
			sqlgraph.To(reaction.Table, reaction.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, poll.ReactionsTable, poll.ReactionsColumn),
		)
		fromV = sqlgraph.Neighbors(po.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PollClient) Hooks() []Hook {
	return c.hooks.Poll
}

// ReactionClient is a client for the Reaction schema.
type ReactionClient struct {
	config
}

// NewReactionClient returns a client for the Reaction from the given config.
func NewReactionClient(c config) *ReactionClient {
	return &ReactionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `reaction.Hooks(f(g(h())))`.
func (c *ReactionClient) Use(hooks ...Hook) {
	c.hooks.Reaction = append(c.hooks.Reaction, hooks...)
}

// Create returns a builder for creating a Reaction entity.
func (c *ReactionClient) Create() *ReactionCreate {
	mutation := newReactionMutation(c.config, OpCreate)
	return &ReactionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Reaction entities.
func (c *ReactionClient) CreateBulk(builders ...*ReactionCreate) *ReactionCreateBulk {
	return &ReactionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Reaction.
func (c *ReactionClient) Update() *ReactionUpdate {
	mutation := newReactionMutation(c.config, OpUpdate)
	return &ReactionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ReactionClient) UpdateOne(r *Reaction) *ReactionUpdateOne {
	mutation := newReactionMutation(c.config, OpUpdateOne, withReaction(r))
	return &ReactionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ReactionClient) UpdateOneID(id int) *ReactionUpdateOne {
	mutation := newReactionMutation(c.config, OpUpdateOne, withReactionID(id))
	return &ReactionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Reaction.
func (c *ReactionClient) Delete() *ReactionDelete {
	mutation := newReactionMutation(c.config, OpDelete)
	return &ReactionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ReactionClient) DeleteOne(r *Reaction) *ReactionDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ReactionClient) DeleteOneID(id int) *ReactionDeleteOne {
	builder := c.Delete().Where(reaction.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ReactionDeleteOne{builder}
}

// Query returns a query builder for Reaction.
func (c *ReactionClient) Query() *ReactionQuery {
	return &ReactionQuery{
		config: c.config,
	}
}

// Get returns a Reaction entity by its id.
func (c *ReactionClient) Get(ctx context.Context, id int) (*Reaction, error) {
	return c.Query().Where(reaction.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ReactionClient) GetX(ctx context.Context, id int) *Reaction {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTemplate queries the template edge of a Reaction.
func (c *ReactionClient) QueryTemplate(r *Reaction) *ReactionTemplateQuery {
	query := &ReactionTemplateQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(reaction.Table, reaction.FieldID, id),
			sqlgraph.To(reactiontemplate.Table, reactiontemplate.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, reaction.TemplateTable, reaction.TemplateColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPoll queries the poll edge of a Reaction.
func (c *ReactionClient) QueryPoll(r *Reaction) *PollQuery {
	query := &PollQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(reaction.Table, reaction.FieldID, id),
			sqlgraph.To(poll.Table, poll.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, reaction.PollTable, reaction.PollColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ReactionClient) Hooks() []Hook {
	return c.hooks.Reaction
}

// ReactionTemplateClient is a client for the ReactionTemplate schema.
type ReactionTemplateClient struct {
	config
}

// NewReactionTemplateClient returns a client for the ReactionTemplate from the given config.
func NewReactionTemplateClient(c config) *ReactionTemplateClient {
	return &ReactionTemplateClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `reactiontemplate.Hooks(f(g(h())))`.
func (c *ReactionTemplateClient) Use(hooks ...Hook) {
	c.hooks.ReactionTemplate = append(c.hooks.ReactionTemplate, hooks...)
}

// Create returns a builder for creating a ReactionTemplate entity.
func (c *ReactionTemplateClient) Create() *ReactionTemplateCreate {
	mutation := newReactionTemplateMutation(c.config, OpCreate)
	return &ReactionTemplateCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ReactionTemplate entities.
func (c *ReactionTemplateClient) CreateBulk(builders ...*ReactionTemplateCreate) *ReactionTemplateCreateBulk {
	return &ReactionTemplateCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ReactionTemplate.
func (c *ReactionTemplateClient) Update() *ReactionTemplateUpdate {
	mutation := newReactionTemplateMutation(c.config, OpUpdate)
	return &ReactionTemplateUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ReactionTemplateClient) UpdateOne(rt *ReactionTemplate) *ReactionTemplateUpdateOne {
	mutation := newReactionTemplateMutation(c.config, OpUpdateOne, withReactionTemplate(rt))
	return &ReactionTemplateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ReactionTemplateClient) UpdateOneID(id int) *ReactionTemplateUpdateOne {
	mutation := newReactionTemplateMutation(c.config, OpUpdateOne, withReactionTemplateID(id))
	return &ReactionTemplateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ReactionTemplate.
func (c *ReactionTemplateClient) Delete() *ReactionTemplateDelete {
	mutation := newReactionTemplateMutation(c.config, OpDelete)
	return &ReactionTemplateDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ReactionTemplateClient) DeleteOne(rt *ReactionTemplate) *ReactionTemplateDeleteOne {
	return c.DeleteOneID(rt.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ReactionTemplateClient) DeleteOneID(id int) *ReactionTemplateDeleteOne {
	builder := c.Delete().Where(reactiontemplate.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ReactionTemplateDeleteOne{builder}
}

// Query returns a query builder for ReactionTemplate.
func (c *ReactionTemplateClient) Query() *ReactionTemplateQuery {
	return &ReactionTemplateQuery{
		config: c.config,
	}
}

// Get returns a ReactionTemplate entity by its id.
func (c *ReactionTemplateClient) Get(ctx context.Context, id int) (*ReactionTemplate, error) {
	return c.Query().Where(reactiontemplate.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ReactionTemplateClient) GetX(ctx context.Context, id int) *ReactionTemplate {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPoll queries the poll edge of a ReactionTemplate.
func (c *ReactionTemplateClient) QueryPoll(rt *ReactionTemplate) *PollQuery {
	query := &PollQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(reactiontemplate.Table, reactiontemplate.FieldID, id),
			sqlgraph.To(poll.Table, poll.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, reactiontemplate.PollTable, reactiontemplate.PollColumn),
		)
		fromV = sqlgraph.Neighbors(rt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ReactionTemplateClient) Hooks() []Hook {
	return c.hooks.ReactionTemplate
}

// VoteClient is a client for the Vote schema.
type VoteClient struct {
	config
}

// NewVoteClient returns a client for the Vote from the given config.
func NewVoteClient(c config) *VoteClient {
	return &VoteClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `vote.Hooks(f(g(h())))`.
func (c *VoteClient) Use(hooks ...Hook) {
	c.hooks.Vote = append(c.hooks.Vote, hooks...)
}

// Create returns a builder for creating a Vote entity.
func (c *VoteClient) Create() *VoteCreate {
	mutation := newVoteMutation(c.config, OpCreate)
	return &VoteCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Vote entities.
func (c *VoteClient) CreateBulk(builders ...*VoteCreate) *VoteCreateBulk {
	return &VoteCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Vote.
func (c *VoteClient) Update() *VoteUpdate {
	mutation := newVoteMutation(c.config, OpUpdate)
	return &VoteUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VoteClient) UpdateOne(v *Vote) *VoteUpdateOne {
	mutation := newVoteMutation(c.config, OpUpdateOne, withVote(v))
	return &VoteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VoteClient) UpdateOneID(id int) *VoteUpdateOne {
	mutation := newVoteMutation(c.config, OpUpdateOne, withVoteID(id))
	return &VoteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Vote.
func (c *VoteClient) Delete() *VoteDelete {
	mutation := newVoteMutation(c.config, OpDelete)
	return &VoteDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VoteClient) DeleteOne(v *Vote) *VoteDeleteOne {
	return c.DeleteOneID(v.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VoteClient) DeleteOneID(id int) *VoteDeleteOne {
	builder := c.Delete().Where(vote.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VoteDeleteOne{builder}
}

// Query returns a query builder for Vote.
func (c *VoteClient) Query() *VoteQuery {
	return &VoteQuery{
		config: c.config,
	}
}

// Get returns a Vote entity by its id.
func (c *VoteClient) Get(ctx context.Context, id int) (*Vote, error) {
	return c.Query().Where(vote.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VoteClient) GetX(ctx context.Context, id int) *Vote {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTemplate queries the template edge of a Vote.
func (c *VoteClient) QueryTemplate(v *Vote) *VoteTemplateQuery {
	query := &VoteTemplateQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := v.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vote.Table, vote.FieldID, id),
			sqlgraph.To(votetemplate.Table, votetemplate.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, vote.TemplateTable, vote.TemplateColumn),
		)
		fromV = sqlgraph.Neighbors(v.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPoll queries the poll edge of a Vote.
func (c *VoteClient) QueryPoll(v *Vote) *PollQuery {
	query := &PollQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := v.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vote.Table, vote.FieldID, id),
			sqlgraph.To(poll.Table, poll.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, vote.PollTable, vote.PollColumn),
		)
		fromV = sqlgraph.Neighbors(v.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VoteClient) Hooks() []Hook {
	return c.hooks.Vote
}

// VoteTemplateClient is a client for the VoteTemplate schema.
type VoteTemplateClient struct {
	config
}

// NewVoteTemplateClient returns a client for the VoteTemplate from the given config.
func NewVoteTemplateClient(c config) *VoteTemplateClient {
	return &VoteTemplateClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `votetemplate.Hooks(f(g(h())))`.
func (c *VoteTemplateClient) Use(hooks ...Hook) {
	c.hooks.VoteTemplate = append(c.hooks.VoteTemplate, hooks...)
}

// Create returns a builder for creating a VoteTemplate entity.
func (c *VoteTemplateClient) Create() *VoteTemplateCreate {
	mutation := newVoteTemplateMutation(c.config, OpCreate)
	return &VoteTemplateCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VoteTemplate entities.
func (c *VoteTemplateClient) CreateBulk(builders ...*VoteTemplateCreate) *VoteTemplateCreateBulk {
	return &VoteTemplateCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VoteTemplate.
func (c *VoteTemplateClient) Update() *VoteTemplateUpdate {
	mutation := newVoteTemplateMutation(c.config, OpUpdate)
	return &VoteTemplateUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VoteTemplateClient) UpdateOne(vt *VoteTemplate) *VoteTemplateUpdateOne {
	mutation := newVoteTemplateMutation(c.config, OpUpdateOne, withVoteTemplate(vt))
	return &VoteTemplateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VoteTemplateClient) UpdateOneID(id int) *VoteTemplateUpdateOne {
	mutation := newVoteTemplateMutation(c.config, OpUpdateOne, withVoteTemplateID(id))
	return &VoteTemplateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VoteTemplate.
func (c *VoteTemplateClient) Delete() *VoteTemplateDelete {
	mutation := newVoteTemplateMutation(c.config, OpDelete)
	return &VoteTemplateDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VoteTemplateClient) DeleteOne(vt *VoteTemplate) *VoteTemplateDeleteOne {
	return c.DeleteOneID(vt.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VoteTemplateClient) DeleteOneID(id int) *VoteTemplateDeleteOne {
	builder := c.Delete().Where(votetemplate.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VoteTemplateDeleteOne{builder}
}

// Query returns a query builder for VoteTemplate.
func (c *VoteTemplateClient) Query() *VoteTemplateQuery {
	return &VoteTemplateQuery{
		config: c.config,
	}
}

// Get returns a VoteTemplate entity by its id.
func (c *VoteTemplateClient) Get(ctx context.Context, id int) (*VoteTemplate, error) {
	return c.Query().Where(votetemplate.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VoteTemplateClient) GetX(ctx context.Context, id int) *VoteTemplate {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPoll queries the poll edge of a VoteTemplate.
func (c *VoteTemplateClient) QueryPoll(vt *VoteTemplate) *PollQuery {
	query := &PollQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := vt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(votetemplate.Table, votetemplate.FieldID, id),
			sqlgraph.To(poll.Table, poll.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, votetemplate.PollTable, votetemplate.PollColumn),
		)
		fromV = sqlgraph.Neighbors(vt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VoteTemplateClient) Hooks() []Hook {
	return c.hooks.VoteTemplate
}
